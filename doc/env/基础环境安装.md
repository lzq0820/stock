
# 数据库基础环境安装

## 1、docker 安装 MySQL

```bash
docker pull mysql:8

docker run -d \
  --name mysql8 \
  --restart=always \
  -p 3306:3306 \
  -v /liuzhq/data/docker/mysql/log:/var/log/mysql \
  -v /liuzhq/data/docker/mysql/data:/var/lib/mysql \
  -v /liuzhq/data/docker/mysql/conf:/etc/mysql/my.cnf.d \
  -e MYSQL_ROOT_PASSWORD=123456 \
  -e MYSQL_ROOT_HOST=% \
  -e TZ=Asia/Shanghai \
  --privileged=true \
  --memory=2G \
  mysql:8 \
  --character-set-server=utf8mb4 \
  --collation-server=utf8mb4_unicode_ci \
  --lower_case_table_names=1 \
  --default-authentication-plugin=mysql_native_password
```


# 2、python 3.10.0rc2安装[百度/AI]

# 3、安装akshare[百度/AI]

# 4、启动python程序
## 4.1、修改python环境变量[start_akshare_api.bat和stop_akshare_api.bat]
![修改启动脚本的python环境变量.png](RunPython/%E4%BF%AE%E6%94%B9%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E7%9A%84python%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png)

## 4.2、python依赖安装
```bash
pip install akshare fastapi uvicorn cachetools tenacity requests urllib3
```

## 4.3、启动python程序
```bash
.\start_akshare_api.bat
```

## 4.4、终止端口占用
### 4.4.1、windows
```bash
PS C:\Users\lzq08> netstat -ano | findstr :8000 | findstr LISTENING
  TCP    0.0.0.0:8000           0.0.0.0:0              LISTENING       18408
PS C:\Users\lzq08> taskkill /f /pid 18408
```


# 5、AI提问
## 5.1、生成后端和数据库代码
### 5.1.1、数据原型
```txt
```

### 5.1.2、提问关键字
```txt
# 应用服务 WEB 访问端口
server:
  port: 19997
  servlet:
    context-path: /baseInfo

spring:
  application:
    name: BASEINFO

  # 数据源配置（改为通用格式，兼容所有SpringBoot版本）
  datasource:
    type: com.zaxxer.hikari.HikariDataSource
    url: jdbc:mysql://xxx/liuzhq?serverTimezone=UTC&useSSL=false&allowPublicKeyRetrieval=true
    username: liuzhq
    password: 123456
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5
      idle-timeout: 300000
      connection-timeout: 20000
      max-lifetime: 1800000
      connection-test-query: SELECT 1
      pool-name: BaseInfoHikariCP
  # MyBatis配置
  mybatis-plus:
    mapper-locations: classpath:mapper/**/*.xml
    type-aliases-package: com.liuzhq.stock.BaseInfo.entity
    configuration:
      map-underscore-to-camel-case: true
      log-impl: org.apache.ibatis.logging.stdout.StdOutImpl

# 日志配置
logging:
  level:
    com.liuzhq.stock.BaseInfo.mapper: debug
    com.zaxxer.hikari: info

# 自定义配置
custom:
  # python环境路径
  python-path: D:\app\develop\python3\python.exe
  # python脚本路径（相对resources路径）
  stock-sse-summary-path: script/stock_sse_summary.py
  szse-sector-summary-path: script/szse_sector_summary.py
  stock-zt-pool-path: script/stock_zt_pool.py
  stock-dt-pool-path: script/stock_dt_pool.py
  # 脚本执行超时时间（毫秒）
  script-timeout: 30000
  # akshare 接口配置
  akshare:
    timeout: 10000

python:
  api:
    base-url: http://localhost:8000/api  # Python服务的地址和端口

提供一个python脚本用于解析文档里面的涨停、跌停、昨日涨停、炸板池、强势股池，需要考虑到数据空或Nonetype等情况，并提供api给Java（jdk8+springboot+mysql8+mybatisplus）代码用于存储数据，存储的数据需要记录是哪天的数据、最高封单金额、当前封单金额，如果没有这个数据就预留字段，提供Java代码用于存储数据和接口用于apifox调试查看
python脚本模板：
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
选股宝涨跌停数据API服务（适配Java SpringBoot调用）
地址：http://localhost:8000
文档：http://localhost:8000/docs
"""
import logging
import re
import sys
import json
import os
from datetime import datetime, timedelta
from typing import Optional, List, Dict, Any

import requests
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from cachetools import TTLCache
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import urllib3
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type

# ========== 配置日志编码，解决中文乱码 ==========
sys.stdout.reconfigure(encoding='utf-8')
sys.stderr.reconfigure(encoding='utf-8')

# 配置日志
try:
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        handlers=[
            logging.StreamHandler(),
            logging.FileHandler(
                "xuangubao_stock_api.log",
                mode='a',
                encoding='utf-8'
            )
        ]
    )
except PermissionError:
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        handlers=[logging.StreamHandler()]
    )
logger = logging.getLogger("xuangubao_stock_api")

# FastAPI应用
app = FastAPI(title="选股宝涨跌停数据API", version="1.0")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["GET"],
    allow_headers=["*"],
)

# 5分钟本地缓存（减轻接口压力）
cache = TTLCache(maxsize=200, ttl=300)

# ========== 禁用代理，确保接口访问正常 ==========
# 清除所有代理相关环境变量
proxy_env_vars = ['http_proxy', 'https_proxy', 'HTTP_PROXY', 'HTTPS_PROXY', 'all_proxy', 'ALL_PROXY']
for var in proxy_env_vars:
    os.environ.pop(var, None)

# 禁用urllib3警告
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def init_session() -> requests.Session:
    """初始化请求会话，配置重试和超时"""
    session = requests.Session()
    session.verify = False
    session.trust_env = False  # 强制不使用代理

    # 配置重试策略
    retry_strategy = Retry(
        total=3,
        backoff_factor=0.5,
        allowed_methods=["GET"],
        status_forcelist=[429, 500, 502, 503, 504]
    )
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount("https://", adapter)
    session.mount("http://", adapter)

    # 超时设置
    session.timeout = 15

    # 请求头伪装
    session.headers.update({
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "Referer": "https://xuangubao.com.cn",
        "Accept": "application/json, text/plain, */*",
        "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8"
    })
    return session

session = init_session()

# ========== 启动服务 ==========
if __name__ == "__main__":
    import uvicorn

    # 打印依赖安装提示
    required_packages = [
        "requests>=2.31.0",
        "fastapi>=0.104.1",
        "uvicorn>=0.24.0",
        "cachetools>=5.3.2",
        "tenacity>=8.2.3",
        "urllib3>=2.0.7"
    ]
    logger.info("=" * 50)
    logger.info("依赖安装命令:")
    logger.info(f"pip install {' '.join(required_packages)}")
    logger.info("=" * 50)

    # 启动服务（绑定所有IP，端口8000）
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        log_level="info",
        access_log=True
    )

Java调用python的api的客户端如下：
package com.liuzhq.stock.BaseInfo.client;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;
import java.util.HashMap;

/**
 * 修复泛型问题：支持复杂泛型类型（如List<Map<String, String>>）的Python API调用工具类
 */
@Component
public class PythonApiClient {
    private static final Logger logger = LoggerFactory.getLogger(PythonApiClient.class);
    private static final ObjectMapper objectMapper = new ObjectMapper();

    // Python API服务地址（可配置在application.yml中）
    @Value("${python.api.base-url:http://localhost:8000/api}")
    private String pythonApiBaseUrl;

    // 初始化RestTemplate并设置超时
    private final RestTemplate restTemplate = new RestTemplate();

    /**
     * 通用调用方法（支持复杂泛型类型）
     * @param path API路径（如/zt/summary）
     * @param params 请求参数
     * @param typeReference 复杂泛型类型引用（如new TypeReference<List<Map<String, String>>>() {}）
     * @param <T> 返回值类型
     * @return 解析后的泛型数据
     */
    private <T> T callPythonApi(String path, Map<String, String> params, TypeReference<T> typeReference) {
        try {
            // 1. 拼接完整URL
            String url = pythonApiBaseUrl + path;
            logger.info("调用Python API：{}，参数：{}", url, params);

            // 2. 发送GET请求（处理空参数）
            ResponseEntity<String> response;
            if (params == null || params.isEmpty()) {
                response = restTemplate.getForEntity(url, String.class);
            } else {
                // 拼接参数到URL（解决RestTemplate GET请求参数传递问题）
                StringBuilder urlWithParams = new StringBuilder(url).append("?");
                for (Map.Entry<String, String> entry : params.entrySet()) {
                    urlWithParams.append(entry.getKey()).append("=").append(entry.getValue()).append("&");
                }
                // 移除最后一个&
                String finalUrl = urlWithParams.substring(0, urlWithParams.length() - 1);
                response = restTemplate.getForEntity(finalUrl, String.class);
            }

            // 3. 校验HTTP响应状态
            if (response.getStatusCode() != HttpStatus.OK) {
                throw new RuntimeException("Python API返回异常状态码：" + response.getStatusCode());
            }

            // 4. 获取响应体
            String responseBody = response.getBody();
            if (responseBody == null || responseBody.isEmpty()) {
                throw new RuntimeException("Python API返回空数据");
            }

            // 5. 解析JSON为Map（先获取业务状态）
            Map<String, Object> resultMap = objectMapper.readValue(responseBody, new TypeReference<Map<String, Object>>() {});

            // 6. 校验业务状态码
            int code = ((Number) resultMap.get("code")).intValue();
            if (code != 200) {
                String msg = (String) resultMap.get("msg");
                throw new RuntimeException("Python API业务异常：" + msg);
            }

            // 7. 提取data字段并转换为目标泛型类型
            Object dataObj = resultMap.get("data");
            String dataJson = objectMapper.writeValueAsString(dataObj);
            T result = objectMapper.readValue(dataJson, typeReference);

            return result;

        } catch (Exception e) {
            logger.error("调用Python API失败", e);
            throw new RuntimeException("调用Python API失败：" + e.getMessage());
        }
    }
}
```
